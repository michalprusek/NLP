---
phase: 05-advanced-flow-methods
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - study/flow_matching/coupling/reflow.py
  - study/flow_matching/coupling/__init__.py
  - study/flow_matching/reflow/__init__.py
  - study/flow_matching/reflow/pair_generator.py
  - study/flow_matching/reflow/train_reflow.py
autonomous: true

must_haves:
  truths:
    - "ReflowPairGenerator produces (x0, x1) pairs via ODE integration from teacher"
    - "ReflowCoupling uses pre-generated pairs for training"
    - "2-rectified flow trains on synthetic pairs without errors"
    - "Reflow produces measurably straighter paths than I-CFM baseline"
  artifacts:
    - path: "study/flow_matching/reflow/pair_generator.py"
      provides: "ReflowPairGenerator class with generate_pairs() method"
      exports: ["ReflowPairGenerator"]
    - path: "study/flow_matching/coupling/reflow.py"
      provides: "ReflowCoupling class compatible with FlowTrainer"
      exports: ["ReflowCoupling"]
    - path: "study/checkpoints/mlp-reflow-1k-none/best.pt"
      provides: "Trained 2-rectified flow checkpoint"
  key_links:
    - from: "study/flow_matching/reflow/pair_generator.py"
      to: "study/checkpoints/mlp-otcfm-1k-none/best.pt"
      via: "loads teacher model for pair generation"
      pattern: "load_checkpoint.*otcfm"
    - from: "study/flow_matching/coupling/reflow.py"
      to: "study/flow_matching/trainer.py"
      via: "provides sample() method matching coupling interface"
      pattern: "def sample.*x0.*x1"
---

<objective>
Implement Rectified Flow with the reflow procedure for straighter ODE paths.

Purpose: Reflow iteratively straightens flow trajectories by generating (noise, ODE_endpoint) pairs from a teacher model and retraining on these synthetic pairs. This enables faster sampling with fewer ODE steps.

Output:
- ReflowPairGenerator class that generates synthetic training pairs from OT-CFM teacher
- ReflowCoupling class compatible with existing FlowTrainer
- Trained 2-rectified flow model with path straightness comparison
</objective>

<execution_context>
@/home/prusek/.claude/get-shit-done/workflows/execute-plan.md
@/home/prusek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-advanced-flow-methods/05-RESEARCH.md

Reference files:
@study/flow_matching/coupling/__init__.py (coupling factory pattern)
@study/flow_matching/coupling/icfm.py (sample() interface)
@study/flow_matching/evaluate.py (euler_ode_integrate, compute_path_straightness)
@study/flow_matching/trainer.py (FlowTrainer, coupling usage)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ReflowPairGenerator and ReflowCoupling</name>
  <files>
    study/flow_matching/reflow/__init__.py
    study/flow_matching/reflow/pair_generator.py
    study/flow_matching/coupling/reflow.py
    study/flow_matching/coupling/__init__.py
  </files>
  <action>
Create the reflow infrastructure:

1. Create `study/flow_matching/reflow/` directory with __init__.py

2. Implement `study/flow_matching/reflow/pair_generator.py`:
   - ReflowPairGenerator class with __init__(teacher_model, n_steps=100)
   - generate_pairs(n_pairs, device) method that:
     * Samples x0 ~ N(0, I) of shape [n_pairs, 1024]
     * Integrates ODE from t=0 to t=1 using Euler (100 steps default)
     * Returns (x0, x1) tuple where x1 is the ODE endpoint
   - Use @torch.no_grad() for inference
   - Teacher model should be in eval mode (frozen)
   - Match existing euler_ode_integrate pattern from evaluate.py
   - Add generate_dataset(n_total, batch_size, device) convenience method for batch generation

3. Implement `study/flow_matching/coupling/reflow.py`:
   - ReflowCoupling class that accepts pair_tensors (x0_all, x1_all) in __init__
   - sample(x0, x1) method that:
     * Ignores the x0, x1 inputs (data batch)
     * Samples a random batch from stored pairs
     * Returns (t, x_t, u_t) matching I-CFM interface
     * t sampled uniformly [0, 1]
     * x_t = (1-t)*x0_pair + t*x1_pair (linear interpolation)
     * u_t = x1_pair - x0_pair (constant velocity)
   - Track current index for epoch-style iteration
   - reset() method to reshuffle pairs each epoch

4. Update `study/flow_matching/coupling/__init__.py`:
   - Add ReflowCoupling import
   - Update create_coupling() to handle 'reflow' method
   - For reflow, accept pair_tensors kwarg

Key implementation notes:
- ReflowCoupling ignores the x0, x1 from data loader - it uses its own stored pairs
- This means the trainer's x1 (data) is unused during reflow training
- Single reflow iteration is sufficient (2-rectified flow)
- Store pairs on CPU, move to GPU during sample() to save VRAM
  </action>
  <verify>
```bash
# Test imports work
cd /home/prusek/NLP && uv run python -c "
from study.flow_matching.reflow.pair_generator import ReflowPairGenerator
from study.flow_matching.coupling.reflow import ReflowCoupling
from study.flow_matching.coupling import create_coupling
print('Imports OK')

# Test ReflowPairGenerator with a dummy model
import torch
import torch.nn as nn

class DummyVelocity(nn.Module):
    def forward(self, x, t):
        return torch.zeros_like(x)  # Zero velocity = endpoint equals start

dummy = DummyVelocity()
gen = ReflowPairGenerator(dummy, n_steps=10)
x0, x1 = gen.generate_pairs(n_pairs=8, device='cpu')
print(f'Pair shapes: x0={x0.shape}, x1={x1.shape}')
assert x0.shape == (8, 1024) and x1.shape == (8, 1024)
print('ReflowPairGenerator OK')

# Test ReflowCoupling
coupling = ReflowCoupling(pair_tensors=(x0, x1))
t, x_t, u_t = coupling.sample(None, None)  # Ignores inputs
print(f'Coupling output shapes: t={t.shape}, x_t={x_t.shape}, u_t={u_t.shape}')
assert t.shape[0] == 8 and x_t.shape == (8, 1024) and u_t.shape == (8, 1024)
print('ReflowCoupling OK')

# Test factory
# Note: reflow needs pair_tensors, so test that ValueError is raised without them
try:
    create_coupling('reflow')  # Should fail without pair_tensors
    assert False, 'Should have raised'
except (ValueError, TypeError) as e:
    print(f'Factory validation OK: {e}')
print('All reflow infrastructure tests passed')
"
```
  </verify>
  <done>
- ReflowPairGenerator generates (x0, x1) pairs via ODE integration
- ReflowCoupling samples from pre-generated pairs with correct interface
- Factory function supports 'reflow' method
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate reflow pairs and train 2-rectified flow</name>
  <files>
    study/flow_matching/reflow/train_reflow.py
  </files>
  <action>
Create training script and run reflow training:

1. Create `study/flow_matching/reflow/train_reflow.py`:
   - Load OT-CFM teacher from study/checkpoints/mlp-otcfm-1k-none/best.pt
   - Generate 10K reflow pairs (10x dataset size as per research)
   - Save pairs to study/datasets/reflow_pairs_1k.pt for reproducibility
   - Train new MLP model on synthetic pairs using ReflowCoupling
   - Use same hyperparameters as OT-CFM baseline (epochs=100, batch_size=256, lr=1e-4)
   - Log to Wandb with group="05-reflow" and run_name="mlp-reflow-1k-none"
   - Save checkpoint to study/checkpoints/mlp-reflow-1k-none/

Key training details:
- Use CUDA_VISIBLE_DEVICES=1 (A5000 GPU per project constraints)
- The trainer's train_dataset is a dummy - ReflowCoupling ignores it
- But we need a dataset for epoch length - use the pair count for sizing
- ReflowCoupling.reset() should be called each epoch to reshuffle
- Use WANDB_MODE=offline if WANDB auth issues (per blockers)

2. Run pair generation and training:
```bash
CUDA_VISIBLE_DEVICES=1 WANDB_MODE=offline uv run python -m study.flow_matching.reflow.train_reflow
```

3. After training completes, evaluate path straightness:
```bash
CUDA_VISIBLE_DEVICES=1 uv run python -c "
import torch
from study.flow_matching.evaluate import load_checkpoint, compute_path_straightness

# Load reflow model
model, stats = load_checkpoint('study/checkpoints/mlp-reflow-1k-none/best.pt', 'mlp', 'cuda:0')

# Compute path straightness
results = compute_path_straightness(
    model=model,
    test_embeddings=torch.randn(100, 1024),  # Not used for this metric
    n_samples=100,
    n_steps=100,
    device='cuda:0'
)
print(f'Reflow path straightness: mean_dev={results[\"mean_path_deviation\"]:.4f}')
print('Compare to I-CFM baseline: ~0.0016')
"
```
  </action>
  <verify>
```bash
# Verify checkpoint exists
ls -la /home/prusek/NLP/study/checkpoints/mlp-reflow-1k-none/best.pt

# Verify model loads and generates coherent text
CUDA_VISIBLE_DEVICES=1 uv run python -c "
import torch
from study.flow_matching.evaluate import load_checkpoint, generate_and_decode
from rielbo.decoder import SonarDecoder

model, stats = load_checkpoint('study/checkpoints/mlp-reflow-1k-none/best.pt', 'mlp', 'cuda:0')
decoder = SonarDecoder(device='cuda:0')

texts = generate_and_decode(model, stats, decoder, n_samples=3, n_steps=100, device='cuda:0')
print('Generated texts:')
for i, t in enumerate(texts, 1):
    print(f'[{i}] {t}')
"
```
  </verify>
  <done>
- Reflow pairs generated from OT-CFM teacher (10K pairs)
- 2-rectified flow model trained on synthetic pairs
- Checkpoint saved at study/checkpoints/mlp-reflow-1k-none/best.pt
- Path straightness measured and compared to I-CFM baseline
  </done>
</task>

</tasks>

<verification>
Phase 5 Plan 01 verification:
1. ReflowPairGenerator.generate_pairs() produces valid (x0, x1) tensors
2. ReflowCoupling.sample() returns (t, x_t, u_t) matching coupling interface
3. create_coupling('reflow', pair_tensors=...) works in factory
4. Reflow training completes without NaN loss
5. Reflow checkpoint exists and loads
6. Reflow generates coherent text
7. Reflow path straightness is comparable or better than I-CFM (~0.0016 baseline)
</verification>

<success_criteria>
- ReflowPairGenerator generates pairs via teacher ODE integration
- ReflowCoupling provides compatible interface for FlowTrainer
- 2-rectified flow trains successfully with val loss < 2.5 (comparable to baselines)
- Generated text is coherent (manual verification)
- Path straightness measured (expected similar to baselines since I-CFM already straight)
</success_criteria>

<output>
After completion, create `.planning/phases/05-advanced-flow-methods/05-01-SUMMARY.md`
</output>
