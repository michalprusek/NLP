---
phase: 04-flow-matching-baselines
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - study/flow_matching/evaluate.py
  - study/checkpoints/mlp-otcfm-1k-none/best.pt
autonomous: true

must_haves:
  truths:
    - "OT-CFM trains with mini-batch Sinkhorn coupling"
    - "OT-CFM produces straighter paths than I-CFM (lower path variance)"
    - "Both methods generate valid SONAR embeddings that decode to coherent text"
  artifacts:
    - path: "study/flow_matching/evaluate.py"
      provides: "Path straightness evaluation function"
      contains: "compute_path_straightness"
    - path: "study/checkpoints/mlp-otcfm-1k-none/best.pt"
      provides: "Trained OT-CFM checkpoint for comparison"
  key_links:
    - from: "study/flow_matching/evaluate.py"
      to: "path straightness measurement"
      via: "euler ODE integration"
      pattern: "def compute_path_straightness"
---

<objective>
Train OT-CFM model and implement path straightness metrics for I-CFM vs OT-CFM comparison.

Purpose: OT-CFM should produce straighter flow paths (lower deviation from ideal straight line), which enables faster/more accurate ODE integration. This is a key advantage over I-CFM.

Output: Trained OT-CFM checkpoint, path straightness evaluation function, quantitative comparison.
</objective>

<execution_context>
@/home/prusek/.claude/get-shit-done/workflows/execute-plan.md
@/home/prusek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-flow-matching-baselines/04-RESEARCH.md
@.planning/phases/04-flow-matching-baselines/04-01-SUMMARY.md

Key context:
- I-CFM baseline checkpoint exists: study/checkpoints/mlp-icfm-1k-none/best.pt
- Path straightness measures deviation from ideal straight line (x0 to x1)
- OT-CFM should have lower mean_path_deviation than I-CFM
- Expected training time: ~5-10 min for 1k dataset with early stopping
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add path straightness evaluation function</name>
  <files>study/flow_matching/evaluate.py</files>
  <action>
Add path straightness measurement function to evaluate.py. Insert after the `compute_distribution_mse` function (around line 160):

```python
@torch.no_grad()
def compute_path_straightness(
    model: torch.nn.Module,
    test_embeddings: Tensor,
    n_samples: int,
    n_steps: int,
    device: str | torch.device,
) -> dict:
    """
    Measure how straight the flow trajectories are.

    Compares actual ODE trajectories to ideal straight lines from noise to
    generated samples. OT-CFM should produce straighter paths than I-CFM.

    Process:
    1. Sample noise x0 ~ N(0, I)
    2. Integrate ODE to get trajectory [x_0, x_1, ..., x_T]
    3. Compute ideal straight line from x0 to x_T (final generated sample)
    4. Measure deviation from ideal at each step

    Args:
        model: Velocity network in eval mode.
        test_embeddings: Normalized test embeddings [N, D] (unused, for consistency).
        n_samples: Number of trajectories to evaluate.
        n_steps: Number of ODE integration steps.
        device: Computation device.

    Returns:
        Dictionary with:
            - mean_path_deviation: Average L2 deviation from straight line
            - max_path_deviation: Maximum deviation across all samples/steps
            - path_variance: Variance of deviation along trajectories
            - n_samples: Number of samples evaluated
    """
    device = torch.device(device) if isinstance(device, str) else device
    model.eval()

    # Sample noise starting points
    x0 = torch.randn(n_samples, 1024, device=device)

    dt = 1.0 / n_steps
    x = x0.clone()
    trajectory = [x.clone()]

    # Integrate ODE and record trajectory
    logger.info(f"Computing path straightness for {n_samples} samples, {n_steps} steps...")
    for i in tqdm(range(n_steps), desc="ODE integration", leave=False):
        t = i / n_steps
        t_batch = torch.full((x.shape[0],), t, device=device, dtype=x.dtype)
        v = model(x, t_batch)
        x = x + dt * v
        trajectory.append(x.clone())

    trajectory = torch.stack(trajectory)  # [n_steps+1, n_samples, 1024]
    x_T = trajectory[-1]  # Final generated samples

    # Compute ideal straight path from x0 to x_T
    ts = torch.linspace(0, 1, n_steps + 1, device=device).view(-1, 1, 1)
    ideal_path = (1 - ts) * x0.unsqueeze(0) + ts * x_T.unsqueeze(0)

    # Compute deviation from ideal straight line
    # L2 distance at each step
    deviation = ((trajectory - ideal_path) ** 2).sum(dim=-1).sqrt()  # [steps+1, n_samples]

    # Skip t=0 and t=1 (always zero deviation by construction)
    deviation_interior = deviation[1:-1]  # [steps-1, n_samples]

    mean_deviation = deviation_interior.mean().item()
    max_deviation = deviation_interior.max().item()
    path_variance = deviation_interior.var(dim=0).mean().item()  # avg variance along paths

    logger.info(f"Path straightness: mean={mean_deviation:.4f}, max={max_deviation:.4f}, var={path_variance:.6f}")

    return {
        "mean_path_deviation": mean_deviation,
        "max_path_deviation": max_deviation,
        "path_variance": path_variance,
        "n_samples": n_samples,
    }
```

Also add path straightness to CLI (in main() function, after distribution MSE section around line 370):

```python
# Compute path straightness
print("\n" + "=" * 50)
print("=== Path Straightness ===")
print("=" * 50)
print("(Lower values = straighter paths = better ODE integration)")

straightness_results = compute_path_straightness(
    model=model,
    test_embeddings=test_embeddings,
    n_samples=args.n_mse_samples,
    n_steps=args.n_steps,
    device=args.device,
)

print(f"Mean deviation: {straightness_results['mean_path_deviation']:.4f}")
print(f"Max deviation: {straightness_results['max_path_deviation']:.4f}")
print(f"Path variance: {straightness_results['path_variance']:.6f}")
print(f"Samples: {straightness_results['n_samples']}")
```
  </action>
  <verify>
```bash
# Test path straightness on existing I-CFM checkpoint
CUDA_VISIBLE_DEVICES=1 uv run python -c "
import torch
from study.flow_matching.evaluate import compute_path_straightness, load_checkpoint

model, stats = load_checkpoint('study/checkpoints/mlp-icfm-1k-none/best.pt', 'mlp', 'cuda:0')

# Load test embeddings (for API consistency, though not used)
test_data = torch.load('study/datasets/splits/1k/test.pt', weights_only=False)
test_embeddings = test_data['embeddings']

results = compute_path_straightness(
    model=model,
    test_embeddings=test_embeddings,
    n_samples=50,
    n_steps=50,
    device='cuda:0'
)

print('Path straightness results:')
for k, v in results.items():
    print(f'  {k}: {v}')

assert 'mean_path_deviation' in results
assert 'path_variance' in results
print('Path straightness function works correctly')
"
```
  </verify>
  <done>
    - compute_path_straightness() added to evaluate.py
    - Function returns mean_deviation, max_deviation, path_variance
    - CLI prints path straightness metrics during evaluation
  </done>
</task>

<task type="auto">
  <name>Task 2: Train OT-CFM model and compare path straightness</name>
  <files>study/checkpoints/mlp-otcfm-1k-none/best.pt</files>
  <action>
Train OT-CFM model on 1K dataset and compare path straightness with I-CFM.

1. **Train OT-CFM model:**
```bash
CUDA_VISIBLE_DEVICES=1 uv run python -m study.flow_matching.train \
    --arch mlp --flow otcfm --dataset 1k --group phase4-flow-baselines \
    --epochs 100 --batch-size 256 --lr 1e-4
```

Expected:
- Training should complete with validation loss ~2.0 (similar to I-CFM)
- Checkpoint saved to study/checkpoints/mlp-otcfm-1k-none/best.pt
- May take slightly longer per epoch due to OT computation

2. **Compare path straightness:**
```bash
# I-CFM baseline
CUDA_VISIBLE_DEVICES=1 uv run python -m study.flow_matching.evaluate \
    --checkpoint study/checkpoints/mlp-icfm-1k-none/best.pt \
    --arch mlp \
    --test-split study/datasets/splits/1k/test.pt \
    --n-mse-samples 100 --n-gen-samples 5 --n-steps 100

# OT-CFM
CUDA_VISIBLE_DEVICES=1 uv run python -m study.flow_matching.evaluate \
    --checkpoint study/checkpoints/mlp-otcfm-1k-none/best.pt \
    --arch mlp \
    --test-split study/datasets/splits/1k/test.pt \
    --n-mse-samples 100 --n-gen-samples 5 --n-steps 100
```

3. **Record results for SUMMARY:**
- I-CFM mean path deviation: ___
- OT-CFM mean path deviation: ___
- Path variance comparison
- Text quality comparison (both should produce coherent English)

OT-CFM should have lower mean_path_deviation than I-CFM.
  </action>
  <verify>
```bash
# Verify checkpoint exists and has expected structure
ls -la study/checkpoints/mlp-otcfm-1k-none/best.pt

# Quick evaluation
CUDA_VISIBLE_DEVICES=1 uv run python -c "
import torch
from study.flow_matching.evaluate import load_checkpoint, compute_path_straightness

# Load OT-CFM model
model, stats = load_checkpoint('study/checkpoints/mlp-otcfm-1k-none/best.pt', 'mlp', 'cuda:0')
print(f'OT-CFM model loaded: {sum(p.numel() for p in model.parameters()):,} params')

# Quick path straightness test
test_data = torch.load('study/datasets/splits/1k/test.pt', weights_only=False)
results = compute_path_straightness(model, test_data['embeddings'], n_samples=20, n_steps=50, device='cuda:0')
print(f'OT-CFM mean deviation: {results[\"mean_path_deviation\"]:.4f}')
"
```
  </verify>
  <done>
    - OT-CFM checkpoint exists at study/checkpoints/mlp-otcfm-1k-none/best.pt
    - OT-CFM validation loss ~2.0 (comparable to I-CFM)
    - OT-CFM path deviation measured and compared to I-CFM
    - Both models generate coherent text (verified via evaluation)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Path straightness comparison table:**
| Model | Mean Deviation | Path Variance | Val Loss |
|-------|----------------|---------------|----------|
| I-CFM | ___ | ___ | 2.008 |
| OT-CFM | ___ | ___ | ___ |

OT-CFM mean deviation should be lower than I-CFM.

2. **Text generation quality:**
Both models should decode to coherent English text about problem-solving/reasoning.

3. **Training time comparison:**
OT-CFM may train slightly slower due to OT computation overhead.
</verification>

<success_criteria>
- [ ] compute_path_straightness() function works correctly
- [ ] OT-CFM model trained with validation loss ~2.0
- [ ] OT-CFM checkpoint saved to study/checkpoints/mlp-otcfm-1k-none/best.pt
- [ ] OT-CFM produces straighter paths than I-CFM (lower mean deviation)
- [ ] Both methods generate coherent text via SONAR decoder
</success_criteria>

<output>
After completion, create `.planning/phases/04-flow-matching-baselines/04-02-SUMMARY.md`

Include path straightness comparison table and sample generated texts.
</output>
