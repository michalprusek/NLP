---
phase: 04-flow-matching-baselines
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - study/flow_matching/coupling/__init__.py
  - study/flow_matching/coupling/icfm.py
  - study/flow_matching/coupling/otcfm.py
  - study/flow_matching/trainer.py
  - study/flow_matching/config.py
autonomous: true

must_haves:
  truths:
    - "Coupling abstraction allows switching between I-CFM and OT-CFM"
    - "OT-CFM uses torchcfm.ExactOptimalTransportConditionalFlowMatcher"
    - "trainer.py supports flow method selection via config"
  artifacts:
    - path: "study/flow_matching/coupling/__init__.py"
      provides: "Coupling factory create_coupling()"
      exports: ["create_coupling", "ICFMCoupling", "OTCFMCoupling"]
    - path: "study/flow_matching/coupling/icfm.py"
      provides: "ICFMCoupling class wrapping existing logic"
      min_lines: 30
    - path: "study/flow_matching/coupling/otcfm.py"
      provides: "OTCFMCoupling using torchcfm"
      min_lines: 40
  key_links:
    - from: "study/flow_matching/trainer.py"
      to: "study/flow_matching/coupling"
      via: "create_coupling import and usage"
      pattern: "from study.flow_matching.coupling import create_coupling"
---

<objective>
Implement coupling abstraction layer and OT-CFM using torchcfm library.

Purpose: Enable fair comparison between I-CFM (independent coupling) and OT-CFM (optimal transport coupling) flow matching methods. OT-CFM produces straighter paths, which should improve sampling quality.

Output: Coupling module with factory pattern, FlowTrainer refactored to use coupling abstraction.
</objective>

<execution_context>
@/home/prusek/.claude/get-shit-done/workflows/execute-plan.md
@/home/prusek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-flow-matching-baselines/04-RESEARCH.md

Key context from research:
- torchcfm 1.0.7 is installed, provides ExactOptimalTransportConditionalFlowMatcher
- I-CFM already correctly implemented in trainer.py lines 198-218
- OT-CFM: `t, xt, ut = ot_fm.sample_location_and_conditional_flow(x0, x1)`
- For 1024D SONAR, may need reg >= 0.5 and normalize_cost=True for numerical stability
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create coupling abstraction module</name>
  <files>
    study/flow_matching/coupling/__init__.py
    study/flow_matching/coupling/icfm.py
    study/flow_matching/coupling/otcfm.py
  </files>
  <action>
Create study/flow_matching/coupling/ directory with three files:

1. **icfm.py** - ICFMCoupling class:
```python
class ICFMCoupling:
    """Independent Conditional Flow Matching coupling.

    Samples x0, x1 independently (random pairing).
    This is the baseline CFM method.
    """
    def __init__(self, sigma: float = 0.0):
        self.sigma = sigma

    def sample(self, x0: torch.Tensor, x1: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """Sample t, x_t, u_t for velocity matching.

        ICFM formulation: x_t = (1-t)*x0 + t*x1, u_t = x1 - x0

        Args:
            x0: Source samples (noise) [B, D]
            x1: Target samples (data) [B, D]

        Returns:
            t: Uniformly sampled timesteps [B]
            x_t: Interpolated samples [B, D]
            u_t: Target velocity [B, D]
        """
        # Sample time uniformly
        t = torch.rand(x1.shape[0], device=x1.device)

        # Interpolate
        t_unsqueeze = t.unsqueeze(-1)
        x_t = (1 - t_unsqueeze) * x0 + t_unsqueeze * x1

        # Target velocity
        u_t = x1 - x0

        return t, x_t, u_t
```

2. **otcfm.py** - OTCFMCoupling class:
```python
from torchcfm import ExactOptimalTransportConditionalFlowMatcher

class OTCFMCoupling:
    """Optimal Transport Conditional Flow Matching coupling.

    Uses mini-batch Sinkhorn to pair x0, x1 optimally,
    producing straighter flow paths than I-CFM.
    """
    def __init__(self, sigma: float = 0.0, reg: float = 0.5, normalize_cost: bool = True):
        """
        Args:
            sigma: Noise level for interpolation (default 0.0 for deterministic)
            reg: Sinkhorn regularization (higher = more stable in high-D)
            normalize_cost: Whether to normalize cost matrix (prevents overflow)
        """
        self.fm = ExactOptimalTransportConditionalFlowMatcher(sigma=sigma)
        # Note: torchcfm handles OT internally; reg and normalize_cost are
        # passed if using OTPlanSampler directly (not needed for default use)
        self.sigma = sigma
        self.reg = reg
        self.normalize_cost = normalize_cost

    def sample(self, x0: torch.Tensor, x1: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """Sample t, x_t, u_t with OT-coupled pairs.

        Uses torchcfm to compute optimal transport coupling,
        which reorders x0 to minimize transport cost.

        Args:
            x0: Source samples (noise) [B, D]
            x1: Target samples (data) [B, D]

        Returns:
            t: Uniformly sampled timesteps [B]
            x_t: Interpolated samples (with OT pairing) [B, D]
            u_t: Target velocity (with OT pairing) [B, D]
        """
        t, x_t, u_t = self.fm.sample_location_and_conditional_flow(x0, x1)
        return t, x_t, u_t
```

3. **__init__.py** - Factory function:
```python
from study.flow_matching.coupling.icfm import ICFMCoupling
from study.flow_matching.coupling.otcfm import OTCFMCoupling

def create_coupling(method: str, **kwargs):
    """Create coupling method by name.

    Args:
        method: 'icfm' or 'otcfm'
        **kwargs: Passed to coupling constructor

    Returns:
        Coupling instance with sample() method
    """
    if method == "icfm":
        return ICFMCoupling(**kwargs)
    elif method == "otcfm":
        return OTCFMCoupling(**kwargs)
    else:
        raise ValueError(f"Unknown coupling method: {method}. Choose 'icfm' or 'otcfm'")

__all__ = ["create_coupling", "ICFMCoupling", "OTCFMCoupling"]
```
  </action>
  <verify>
```bash
# Import test
CUDA_VISIBLE_DEVICES=1 python -c "
from study.flow_matching.coupling import create_coupling, ICFMCoupling, OTCFMCoupling
import torch

# Test I-CFM
icfm = create_coupling('icfm')
x0 = torch.randn(32, 1024)
x1 = torch.randn(32, 1024)
t, xt, ut = icfm.sample(x0, x1)
assert t.shape == (32,), f'Expected (32,), got {t.shape}'
assert xt.shape == (32, 1024), f'Expected (32, 1024), got {xt.shape}'
assert ut.shape == (32, 1024), f'Expected (32, 1024), got {ut.shape}'

# Test OT-CFM
otcfm = create_coupling('otcfm')
t, xt, ut = otcfm.sample(x0, x1)
assert t.shape == (32,), f'Expected (32,), got {t.shape}'
print('Coupling module tests passed')
"
```
  </verify>
  <done>
    - create_coupling('icfm') returns ICFMCoupling instance
    - create_coupling('otcfm') returns OTCFMCoupling instance
    - Both sample() methods return (t, x_t, u_t) with correct shapes
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor FlowTrainer to use coupling abstraction</name>
  <files>
    study/flow_matching/trainer.py
    study/flow_matching/config.py
  </files>
  <action>
Modify FlowTrainer to accept and use coupling abstraction:

1. **config.py** - Add OT-CFM specific parameters (after line 45, within the dataclass):
```python
# OT-CFM specific parameters
otcfm_sigma: float = field(default=0.0, repr=False)
otcfm_reg: float = field(default=0.5, repr=False)
otcfm_normalize_cost: bool = field(default=True, repr=False)
```

Also add these to `to_dict()` method for Wandb logging.

2. **trainer.py** - Refactor to use coupling:

Add import at top:
```python
from study.flow_matching.coupling import create_coupling
```

Modify __init__ to create coupling (after line 100, in _setup method, before optimizer creation):
```python
# Create coupling method based on config
coupling_kwargs = {}
if self.config.flow == "otcfm":
    coupling_kwargs = {
        "sigma": self.config.otcfm_sigma,
        "reg": self.config.otcfm_reg,
        "normalize_cost": self.config.otcfm_normalize_cost,
    }
self.coupling = create_coupling(self.config.flow, **coupling_kwargs)
logger.info(f"Using {self.config.flow} coupling method")
```

Modify train_epoch (lines 198-218) to use coupling:
```python
# OLD CODE (lines 201-217):
# Sample noise (source distribution)
x0 = torch.randn_like(x1)

# Sample time uniformly
t = torch.rand(x1.shape[0], device=self.device)

# Interpolate: x_t = (1-t)*x0 + t*x1
t_unsqueeze = t.unsqueeze(-1)
x_t = (1 - t_unsqueeze) * x0 + t_unsqueeze * x1

# Target velocity: v = x1 - x0
v_target = x1 - x0

# NEW CODE:
# Sample noise (source distribution)
x0 = torch.randn_like(x1)

# Get interpolated samples and target velocity from coupling
t, x_t, v_target = self.coupling.sample(x0, x1)
```

Same change for validate method (lines 279-296).
  </action>
  <verify>
```bash
# Quick 1-epoch training test with each coupling method
CUDA_VISIBLE_DEVICES=1 uv run python -c "
import torch
from study.data.dataset import load_all_splits
from study.flow_matching.config import TrainingConfig
from study.flow_matching.models import create_model
from study.flow_matching.trainer import FlowTrainer

# Test I-CFM (should work as before)
config = TrainingConfig(
    arch='mlp', flow='icfm', dataset='1k', aug='none', group='test',
    epochs=1, batch_size=64
)
train_ds, val_ds, _ = load_all_splits(size='1k', stats_path=config.stats_path, return_normalized=True)
model = create_model('mlp')
trainer = FlowTrainer(model, config, train_ds, val_ds, torch.device('cuda'), wandb_project='test-phase4')
# Don't run full training, just verify setup
print(f'I-CFM trainer created with coupling: {type(trainer.coupling).__name__}')
trainer.finish()

# Test OT-CFM
config = TrainingConfig(
    arch='mlp', flow='otcfm', dataset='1k', aug='none', group='test',
    epochs=1, batch_size=64
)
model = create_model('mlp')
trainer = FlowTrainer(model, config, train_ds, val_ds, torch.device('cuda'), wandb_project='test-phase4')
print(f'OT-CFM trainer created with coupling: {type(trainer.coupling).__name__}')
trainer.finish()

print('Trainer integration tests passed')
"
```
  </verify>
  <done>
    - FlowTrainer creates correct coupling based on config.flow
    - I-CFM training produces same results as before (backward compatible)
    - OT-CFM training initializes without errors
    - config.to_dict() includes OT-CFM parameters
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit test coupling module:**
```bash
CUDA_VISIBLE_DEVICES=1 python -c "
from study.flow_matching.coupling import create_coupling
import torch

# Both methods work on 1024D data
x0 = torch.randn(64, 1024)
x1 = torch.randn(64, 1024)

for method in ['icfm', 'otcfm']:
    coupling = create_coupling(method)
    t, xt, ut = coupling.sample(x0, x1)
    assert t.shape == (64,)
    assert xt.shape == (64, 1024)
    assert ut.shape == (64, 1024)
    print(f'{method}: OK')
"
```

2. **2-epoch smoke test with both methods:**
```bash
CUDA_VISIBLE_DEVICES=1 uv run python -m study.flow_matching.train \
    --arch mlp --flow icfm --dataset 1k --group test-coupling \
    --epochs 2 --batch-size 64

CUDA_VISIBLE_DEVICES=1 uv run python -m study.flow_matching.train \
    --arch mlp --flow otcfm --dataset 1k --group test-coupling \
    --epochs 2 --batch-size 64
```

Both should complete without errors. OT-CFM may show slightly different loss values.
</verification>

<success_criteria>
- [ ] create_coupling('icfm') returns working ICFMCoupling
- [ ] create_coupling('otcfm') returns working OTCFMCoupling using torchcfm
- [ ] FlowTrainer uses coupling abstraction based on config.flow
- [ ] Both icfm and otcfm train without errors
- [ ] OT-CFM config parameters (sigma, reg, normalize_cost) in config.py
</success_criteria>

<output>
After completion, create `.planning/phases/04-flow-matching-baselines/04-01-SUMMARY.md`
</output>
